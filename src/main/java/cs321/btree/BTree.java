package cs321.btree;

import java.io.IOException;
import java.util.LinkedList;
import java.util.Queue;

import cs321.btree.BTreeNode;
import cs321.common.Debug;
import cs321.create.GeneBankCreateBTreeArguments;
import cs321.search.GeneBankSearchBTreeArguments;

public class BTree<E>
{
    private BTreeNode root; //dynamic, save to binary file at end

    private int degree;
    private boolean useCache;
    private String gbkFileName;
    private int subsequenceLength;
    private int cacheSize;
    private int debugLevel;
    private int numNodes;
    private final int MAX_KEYS;
    private DiskReadWrite disk;

    /**
     * BTree Constructor for inserting values into the BTree.
     * Sets required instance variables, including an instance
     * of DiskReadWrite to interface with disk/cache.
     * @param args Parsed arguments generated from GeneBankCreateBTreeArguments
     */
    public BTree(GeneBankCreateBTreeArguments args) {        

        this.useCache = args.isUsingCache();
        this.degree = args.getDegree();
        this.gbkFileName = args.getGbkFileName();
        this.subsequenceLength = args.getSubsequenceLength();
        this.cacheSize = args.getCacheSize();
        this.debugLevel = args.getDebugLevel();
        this.MAX_KEYS = 2*degree - 1;
        String btreeFileName = gbkFileName + ".btree.data."+subsequenceLength+"."+degree;

        disk = new DiskReadWrite(btreeFileName, getMetaData(), useCache, cacheSize);
        BTreeNode x = disk.allocateNode();
        x.setLeaf(true);
        disk.write(x);
        root = x;
        numNodes = 1;
        Debug.log("max keys = " + MAX_KEYS);
    }

    /**
     * Creates BTree object for searching values within an existing
     * BTree. The instance of DiskReadWrite is given the Metadata of 
     * the existing tree to parse through, where GeneBankSearchBTree 
     * calls Search() on the root of the pre-created tree.
     * @param args Parsed arguments generated by GeneBankCreateBTreeArguments
     * @param metadata
     */
    public BTree(GeneBankSearchBTreeArguments args, MetaData metadata) {
        String bTreeFileName = args.getBTreeFileName();
        this.cacheSize = args.getCacheSize();
        this.useCache = args.isUsingCache();
        this.degree = args.getDegree();
        this.subsequenceLength = args.getSubsequenceLength();
        this.debugLevel = args.getDebugLevel();
        this.MAX_KEYS = (2*degree) - 1;
        disk = new DiskReadWrite(bTreeFileName, metadata, useCache, cacheSize);
        this.root = disk.read(metadata.getRootAddress());

    }
    
    /**
     * Finishes tree processes, including saving the root,
     * and tells DiskReadWrite to save the metadata.
     */
    public void closeTree() {
        try {
            System.out.println("attempting to close tree");
            disk.write(root);
            disk.finish(getMetaData());
        } catch (IOException e) {
            Debug.logError("Could not close tree." + e.getStackTrace());
        }
    }

    public void insert (long val) {
        Debug.log("\ninserting " + val);
        if(root.getNumKeys() == MAX_KEYS) {
            Debug.log("root full, splitting root");
            BTreeNode split = splitRoot();
            insertNonFull(split, val);
        } else {
            Debug.log("root isnt full");
            insertNonFull(root, val);
        }
    }

    /**
     * Inserts a value into a specified node, which is known
     * to not be full. If the node we try to insert into is
     * not a leaf, we find the child of where it would belong,
     * and recurse to that node. If the node we try to insert
     * into is a leaf, we check where the value would belong, 
     * and insert it there.
     * @param x Node to attempt to insert into. 
     * @param val Value to be inserted. 
     */
    private void insertNonFull(BTreeNode x, long val) {
        Debug.log("______ insertNonFull(x = BTreeNode@" + x.getAddress() + ", val = " + val + ")");
        
        int i = x.getNumKeys()-1;
        TreeObject toInsert = new TreeObject(val);

        TreeObject[] keys = x.getKeys();
        for (int j = 0; j < x.getNumKeys(); j++) {
        //for (int j = 0; j < keys.length; j++) {
            if (keys[j].getKey() == val) {
                x.incFrequency(j);
                disk.write(x);
                return;
            }
        }

        if(x.isLeaf()) {
            while(i >= 0 && val < x.getObjectsKey(i)) {
                Debug.log("val: " + val + " | x.getObjectsKey(i): " + x.getObjectsKey(i));
                x.setKey(i+1, x.getKey(i));
                i--;
            }
            x.setKey(i+1, toInsert);
            x.incSize();
            disk.write(x);
        } else {
            while(i >= 0 && val < x.getObjectsKey(i)) {
                i--;
            }
            i++;
            BTreeNode xIthChild = disk.read(x.getChild(i));
            if(xIthChild.getNumKeys() == MAX_KEYS) {
                splitChild(x, i);
                if(val > x.getObjectsKey(i)) {
                    i++;
                }
            }
            xIthChild = disk.read(x.getChild(i));
            insertNonFull(xIthChild, val);
        }

    }

    /**
     * Splits the @param i th child of input node @param x (y).
     * This will create a new node (z), which gets the greatest
     * keys of y, and the respective children. We then shift x's
     * children to make room for z as a child, and shift the 
     * respective keys in x. We then save the state of these
     * nodes to disk.
     * @param x Node whos @param i th child will be split
     * @param i Index of child to split.
     */    

    private void splitChild(BTreeNode x, int i) {
        Debug.log("Splitting child at address " + x.getAddress() + ". i = " + i);
        BTreeNode y = disk.read(x.getChild(i));
        Debug.log("Object y created from address " + x.getChild(i) + " ----------------------------------------------------------------");
        Debug.log(y.toString());
        BTreeNode z = disk.allocateNode();
        z.setLeaf(y.isLeaf());
        z.setNumKeys(degree-1);
        for(int j = 0; j <= degree-2; j++) {
            z.setKey(j, y.getKey(j + degree));
        }
        if(!y.isLeaf()) {
            for(int j = 0; j <= degree-1; j++) {
                Debug.log("Node@" + z.getAddress() + ": setting child " + j + " to " + y.getChild(j+degree));
                z.setChild(j, y.getChild(j + degree));
            }
            z.setNumChildren(degree);
            y.setNumChildren(degree);
        }
        y.setNumKeys(degree-1);
        for(int j = x.getNumKeys(); j >= i+1; j--) {
            Debug.log("Node@" + x.getAddress() + ": setting child " + (j+1) + " to " + x.getChild(j));
            x.setChild(j+1, x.getChild(j));
        }
        x.setChild(i + 1, z.getAddress());
        for(int j = x.getNumKeys()-1; j >= i; j--) {
            x.setKey(j+1, x.getKey(j));
        }
        x.setKey(i, y.getKey(degree-1));
        x.incSize();
        x.incNumChildren();

        disk.write(y);
        disk.write(z);
        disk.write(x);

        numNodes++;
    }

    /**
     * Creates a dummy node that will become the new root, 
     * and then sets its first child to be the original root.
     * When we split the first child of the dummy, this ensures
     * that the requirement of root having at least 2 children 
     * is satisfied. 
     * @return new root node
     */
    private BTreeNode splitRoot() {
        BTreeNode dummy = disk.allocateNode();
        dummy.setLeaf(false);
        //size already init to 0
        dummy.setChild(0, root); 
        this.root = dummy;
        splitChild(dummy, 0);
        numNodes++;  
        return dummy;
    }

    public void print() {
        inOrderTreeWalk(root);
        Debug.exit();
    }
    

    /**
     * Walks through the BTree in-order, meaning we start
     * at the leftmost node, and work our way towards the 
     * rightmost.
     * @param node , which should be root, otherwise this
     * will in-order traverse the subtree rooted at `node`.
     */
    private void inOrderTreeWalk(BTreeNode node) {
        TreeObject[] keys = node.getKeys();
        if(node.isLeaf()) {
            for(int i = 0; i < node.getNumKeys(); i++) {
                if(keys[i] == null) {
                    
                }
                Debug.dump(keys[i].toString(subsequenceLength));
            }
        } else {
            for(int i = 0; i < node.getNumKeys(); i++) {
                BTreeNode newNode = disk.read(node.getChild(i));
                inOrderTreeWalk(newNode);
                Debug.dump(keys[i].toString(subsequenceLength));
            }
            BTreeNode next = disk.read(node.getChild(node.getNumKeys()));
            inOrderTreeWalk(next);
        }
    }

    public TreeObject search(long key) {
        return searchRecursive(root,key);
    }

    public TreeObject searchRecursive(BTreeNode node, long key) {
        int i = 0;
        while (i < node.getNumKeys() && key > node.getObjectsKey(i)) {
            i++;
        }
        if (i < node.getNumKeys() && key == node.getObjectsKey(i)) {
            return node.getKey(i);
        } else if (node.isLeaf()) {
            return null;
        } else {
            BTreeNode next = disk.read(node.getChild(i));
            return searchRecursive(next,key);
        }
    }
    
    public MetaData getMetaData() {
        if (root == null) {
            return new MetaData(degree, numNodes, debugLevel, new BTreeNode(degree).getObjectSize(), 0);
        } else {
            return new MetaData(degree, numNodes, debugLevel, root.getObjectSize(), root.getAddress());
        }
    }

    public void printCache() {
        disk.printCache();
    }

    public void printDisk() {
        for (int i = 0; i < numNodes; i++) {
            Debug.log(disk.read(i * getMetaData().getNodeSize()).toString());
        }
    }

    public BTreeNode getRoot() {
        return root;
    }
}
